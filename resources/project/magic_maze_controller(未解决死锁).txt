function magic_maze_controller()
    fprintf("🧐 magic_maze_controller 启动（含死锁规避）\n");

    raw_agents = jsondecode(fileread('agent_state.json'));
    agents = struct();
    for i = 1:length(raw_agents)
        agents(i).name = strtrim(lower(char(raw_agents(i).name)));
        agents(i).pos = [raw_agents(i).row, raw_agents(i).col];
        agents(i).phase = "to_item";
        agents(i).path = [];
        agents(i).step = 2;
        agents(i).has_stolen = false;
        agents(i).has_exited = false;
        agents(i).stuck_count = 0;
        fprintf("📌 %s 起始位置: (%d,%d)\n", agents(i).name, agents(i).pos(1), agents(i).pos(2));
    end

    explored_sites = zeros(0, 2);
    assigned_explore_sites = zeros(0, 2);
    max_rounds = 200;
    no_progress_counter = 0;

    for round = 1:max_rounds
        fprintf("\n🔁 回合 %d...\n", round);
        [maze_grid, row_offset, col_offset] = load_maze_grid();
        wall_map = load_wall_map();
        elevator_map = load_elevator_map();
        [item_targets, exit_targets] = find_goal_tiles(maze_grid, row_offset, col_offset);

        raw_agents = jsondecode(fileread('agent_state.json'));
        for i = 1:length(agents)
            idx = find(strcmp({raw_agents.name}, agents(i).name));
            if ~isempty(idx)
                agents(i).has_stolen = raw_agents(idx).has_stolen;
                agents(i).has_exited = raw_agents(idx).has_exited;
            end
        end

        explore_assignments = assign_explore_targets(agents, maze_grid, explored_sites, assigned_explore_sites);
        any_progress = false;

        for i = 1:length(agents)
            a = agents(i); name = a.name;

            if a.phase == "done", continue; end
            if a.phase == "to_item" && a.has_stolen, a.phase = "to_exit"; a.path = []; a.step = 2;
            elseif a.phase == "to_exit" && a.has_exited, a.phase = "done"; agents(i) = a; continue; end

            % === 目标选择 ===
            key = name; goal = [];
            if a.phase == "to_item" && isKey(item_targets, key) && ~a.has_stolen
                goal = item_targets(key);
            elseif a.phase == "to_exit" && isKey(exit_targets, key) && ~a.has_exited
                goal = exit_targets(key);
            elseif isKey(explore_assignments, name)
                goal = explore_assignments(name);
            else
                continue;
            end

            % === 路径规划 ===
            if isempty(a.path) || a.step > size(a.path,1)
                a.path = astar_search(a.pos, goal, maze_grid, wall_map, elevator_map);
                a.step = 2;
                if isempty(a.path)
                    fprintf("❌ %s 无法到达目标 [%d,%d]\n", name, goal(1), goal(2));
                    agents(i) = a; continue;
                end
            end

            if size(a.path,1) == 1
                [maze_r, maze_c] = deal(a.pos(1)-row_offset, a.pos(2)-col_offset);
                if maze_r >= 1 && maze_c >= 1 && maze_r <= size(maze_grid,1) && maze_c <= size(maze_grid,2)
                    if contains(maze_grid{maze_r,maze_c}, "explore")
                        res = send_action("arm1", "explore", name);
                        if strcmp(res.status, "success")
                            explored_sites(end+1,:) = a.pos;
                            for j = 1:length(agents)
                                if j ~= i && agents(j).phase ~= "done"
                                    agents(j).path = []; agents(j).step = 2;
                                end
                            end
                        end
                    end
                end
                a.path = []; a.step = 2; agents(i) = a; continue;
            end

            % === 下一步动作 ===
            from = a.path(a.step-1,:); to = a.path(a.step,:);
            delta = to - from;
            if isequal(delta, [-1 0]), action = "move_up"; arm = "arm1";
            elseif isequal(delta, [1 0]), action = "move_down"; arm = "arm2";
            elseif isequal(delta, [0 -1]), action = "move_left"; arm = "arm2";
            elseif isequal(delta, [0 1]), action = "move_right"; arm = "arm1";
            else, action = "use_elevator"; arm = "arm2"; end

            % === 互卡检测与优先级判断 ===
            for j = 1:length(agents)
                if j == i, continue; end
                b = agents(j);
                if b.step > 1 && b.step <= size(b.path,1)
                    from_b = b.path(b.step-1,:);
                    to_b = b.path(b.step,:);
                    if isequal(from_b, to) && isequal(to_b, from)
                        fprintf("♻️ [%s] 与 [%s] 对位互卡检测\n", name, b.name);
            
                        % 判断是否该 agent 应该让路
                        let_me_yield = false;
            
                        if ~a.has_stolen && b.has_stolen
                            let_me_yield = true;
                            fprintf("🧷 [%s] 还未盗窃，优先让 [%s]\n", name, b.name);
                        elseif a.has_stolen == b.has_stolen
                            if string(name) > string(b.name)  % p1 < p2 < p3 < p4 字符串顺序
                                let_me_yield = true;
                                fprintf("🔢 [%s] 名字顺序靠后，让路给 [%s]\n", name, b.name);
                            end
                        end
            
                        if let_me_yield
                            dirs = [-1 0; 1 0; 0 -1; 0 1];
                            moved = false;
                            for d = 1:4
                                try_to = a.pos + dirs(d,:);
                                if all(arrayfun(@(x) ~isequal(x.pos, try_to), agents)) && ...
                                   ~is_blocked_by_wall(a.pos, try_to, wall_map, "")
                                    delta = try_to - a.pos;
                                    if isequal(delta, [-1 0]), act="move_up"; a_arm="arm1";
                                    elseif isequal(delta, [1 0]), act="move_down"; a_arm="arm2";
                                    elseif isequal(delta, [0 -1]), act="move_left"; a_arm="arm2";
                                    elseif isequal(delta, [0 1]), act="move_right"; a_arm="arm1"; else, continue; end
                                    moved_res = send_action(a_arm, act, name);
                                    if strcmp(moved_res.status, "success")
                                        fprintf("↩️ [%s] 成功让出 [%d,%d]\n", name, try_to(1), try_to(2));
                                        a.pos = try_to; a.path = []; a.step = 2;
                                        moved = true; break;
                                    end
                                end
                            end
            
                            if ~moved
                                fprintf("⛔ [%s] 无法让路，等待...\n", name);
                            end
                            agents(i) = a;
                            continue;  % 当前 agent 让路尝试后跳过本轮
                        else
                            fprintf("🛑 [%s] 拥有优先权，等待对方让路\n", name);
                            a.path = []; a.step = 2;
                            agents(i) = a;
                            continue;
                        end
                    end
                end
            end



            % === 执行动作 ===
            fprintf("▶️ %s 尝试 %s 到 [%d,%d]\n", name, action, to(1), to(2));
            res = send_action(arm, action, name);

            if strcmp(res.status, "success")
                a.pos = to; a.step = a.step + 1; a.stuck_count = 0; any_progress = true;
            else
                fprintf("🧲 %s 执行失败: %s\n", name, res.reason);
                if action == "use_elevator"
                    a.stuck_count = a.stuck_count + 1;

                    blocker = find(arrayfun(@(b) isequal(b.pos, to), agents));
                    if ~isempty(blocker) && a.stuck_count >= 2
                        fprintf("🔄 [%s] 电梯让路尝试\n", name);
                        dirs = [-1 0; 1 0; 0 -1; 0 1];
                        for j = 1:4
                            try_to = a.pos + dirs(j,:);
                            if all(arrayfun(@(b) ~isequal(b.pos, try_to), agents)) && ...
                               ~is_blocked_by_wall(a.pos, try_to, wall_map, "")
                                delta = try_to - a.pos;
                                if isequal(delta, [-1 0]), act="move_up"; a_arm="arm1";
                                elseif isequal(delta, [1 0]), act="move_down"; a_arm="arm2";
                                elseif isequal(delta, [0 -1]), act="move_left"; a_arm="arm2";
                                elseif isequal(delta, [0 1]), act="move_right"; a_arm="arm1"; end
                                moved = send_action(a_arm, act, name);
                                if strcmp(moved.status, "success")
                                    a.pos = try_to; a.path = []; a.step = 2;
                                    break;
                                end
                            end
                        end
                    end

                    if a.stuck_count >= 5
                        fprintf("⛔ [%s] 尝试绕开电梯目标重新规划\n", name);
                        avoid = to;
                        a.path = astar_search_avoid(a.pos, goal, maze_grid, wall_map, elevator_map, avoid);
                        a.step = 2;
                    end
                else
                    a.path = []; a.step = 2;
                end
            end

            agents(i) = a;
        end

        if all(arrayfun(@(a) strcmp(a.phase, "done"), agents))
            fprintf("🎉 所有 agent 成功逃脱！\n"); return;
        end

        if any_progress
            no_progress_counter = 0;
        else
            no_progress_counter = no_progress_counter + 1;
            if no_progress_counter >= 5
                fprintf("❌ 连续 5 回合无进展，终止程序\n"); return;
            else
                fprintf("⏸️ 无进展，等待...\n");
            end
        end

        pause(0.4);
    end

    fprintf("❌ 超出最大回合，失败\n");
end
